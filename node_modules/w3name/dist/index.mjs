import{generateKeyPair as t,publicKeyFromProtobuf as e,privateKeyFromProtobuf as n}from"@libp2p/crypto/keys";import{base36 as i}from"multiformats/bases/base36";import{base64pad as r}from"multiformats/bases/base64";import{CID as o}from"multiformats/cid";import*as s from"multiformats/hashes/digest";import*as a from"ipns";import{validate as c}from"ipns/validator";import*as u from"cborg";import l from"./service.mjs";const d=()=>new Date(Date.now()+31536e6).toISOString(),m=5n*60n*1000n*1000000n,w=new l;class y{_pubKey;_cid;constructor(t){this._pubKey=t,this._cid=t.toCID()}get bytes(){return this._cid.bytes}toString(){return this._cid.toString(i)}}class f extends y{_privKey;constructor(t){super(t.publicKey),this._privKey=t}get key(){return this._privKey}}async function h(){const e=await t("Ed25519",2048);return new f(e)}function p(t){const n=o.parse(t,i);if(114!==n.code)throw new Error(`Invalid key, expected 114 codec code but got ${n.code}`);const r=e(s.decode(n.multihash.bytes).bytes);return new y(r)}async function v(t){const e=n(t);return new f(e)}async function _(t,e){return new b(t,e,0n,d())}async function g(t,e){const n=t.sequence+1n;return new b(t.name,e,n,d())}class b{_name;_value;_sequence;_validity;_ttl;constructor(t,e,n,i,r){if(this._name=t,"string"!=typeof e)throw new Error("invalid value");if(this._value=e,"bigint"!=typeof n)throw new Error("invalid sequence number");if(this._sequence=n,"string"!=typeof i||Number.isNaN(new Date(i).getTime()))throw new Error("invalid validity");this._validity=i;const o=r?.ttl??m;if("bigint"!=typeof o)throw new Error("invalid TTL");this._ttl=o}get name(){return this._name}get value(){return this._value}get sequence(){return this._sequence}get validity(){return this._validity}get ttl(){return this._ttl}static encode(t){return u.encode({name:t._name.toString(),value:t._value,sequence:t._sequence,validity:t._validity,...null!=t._ttl?{ttl:t._ttl}:{}})}static decode(t){const e=u.decode(t),n=p(e.name);return new b(n,e.value,BigInt(e.sequence),e.validity,{ttl:null!=e.ttl?BigInt(e.ttl):void 0})}}async function S(t,e,n=w){const i=new URL(`name/${t.name.toString()}`,n.endpoint),o=await a.createIPNSRecord(e,t.value,t.sequence,new Date(t.validity).getTime()-Date.now(),{ttlNs:t.ttl});await n.waitForRateLimit(),await E(fetch(i.toString(),{method:"POST",body:r.baseEncode(a.marshalIPNSRecord(o))}))}async function q(t,n=w){const i=new URL(`name/${t.toString()}`,n.endpoint);await n.waitForRateLimit();const u=await E(fetch(i.toString())),{record:l}=await u.json(),d=r.baseDecode(l),m=a.unmarshalIPNSRecord(d),y=o.decode(t.bytes),f=e(s.decode(y.multihash.bytes).bytes);return await c(f,d),new b(t,m.value,m.sequence,m.validity,{ttl:m.ttl})}async function E(t){const e=await t;if(e.ok)return e;let n;try{const t=await e.json();n=new Error(t.message)}catch(t){n=new Error(`unexpected response from API, cannot parse error response. Received status: ${e.status}`)}throw n}export{y as Name,b as Revision,f as WritableName,h as create,v as from,g as increment,p as parse,S as publish,q as resolve,_ as v0};
//# sourceMappingURL=index.mjs.map
